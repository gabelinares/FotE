// gridview.js
export const CELL_DEAD='.'; export const CELL_ALIVE='O';
export function parsePattern(txt){const lines=txt.trim().split(/\r?\n/).filter(l=>l.length>0);const h=lines.length;const w=Math.max(...lines.map(l=>l.length));const grid=Array.from({length:h},(_,y)=>Array.from({length:w},(_,x)=>(lines[y][x]===CELL_ALIVE?1:0)));return grid;}
export function serializePattern(grid){return grid.map(r=>r.map(v=>(v?CELL_ALIVE:CELL_DEAD)).join('')).join('\n');}
export function cloneGrid(g){return g.map(r=>r.slice());}
export function dims(g){return [g[0]?.length||0,g.length||0];}
function neighbors(g,x,y){const[W,H]=dims(g);let n=0;for(let dy=-1;dy<=1;dy++){for(let dx=-1;dx<=1;dx++){if(dx===0&&dy===0)continue;const xx=x+dx,yy=y+dy;if(xx>=0&&xx<W&&yy>=0&&yy<H)n+=g[yy][xx]?1:0;}}return n;}
export function step(g){const[W,H]=dims(g);const next=Array.from({length:H},()=>Array(W).fill(0));for(let y=0;y<H;y++){for(let x=0;x<W;x++){const a=g[y][x]?1:0;const n=neighbors(g,x,y);let alive=0;if(a&&(n===2||n===3))alive=1;else if(!a&&n===3)alive=1;next[y][x]=alive;}}return next;}
export function countAlive(g){let c=0;for(const r of g)for(const v of r)c+=v?1:0;return c;}
export function eqGrid(a,b){if(a.length!==b.length)return false;for(let y=0;y<a.length;y++){if(a[y].length!==b[y].length)return false;for(let x=0;x<a[y].length;x++)if(a[y][x]!==b[y][x])return false;}return true;}
export function bboxCoords(g){const[W,H]=dims(g);let minX=W,minY=H,maxX=-1,maxY=-1;for(let y=0;y<H;y++)for(let x=0;x<W;x++)if(g[y][x]){if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}if(maxX===-1)return null;return{minX,minY,maxX,maxY};}
export function aliveCoords(g){const pts=[];for(let y=0;y<g.length;y++)for(let x=0;x<g[y].length;x++)if(g[y][x])pts.push([x,y]);return pts;}
function displacement(before,after){const bb1=bboxCoords(before),bb2=bboxCoords(after);if(!bb1||!bb2)return{dx:0,dy:0};return{dx:bb2.minX-bb1.minX,dy:bb2.minY-bb1.minY};}
export function measure(grid,maxPeriod=10){const initial=cloneGrid(grid);const seen=new Map();const sig=g=>serializePattern(g);let g=cloneGrid(grid);let birthsTotal=0,changesTotal=0;let steps=0;seen.set(sig(g),0);let period=null;for(let i=1;i<=maxPeriod;i++){const prev=g;const nextG=step(g);steps++;let births=0,changes=0;for(let y=0;y<g.length;y++)for(let x=0;x<g[y].length;x++){const a=prev[y][x],b=nextG[y][x];if(!a&&b)births++;if(a!==b)changes++;}birthsTotal+=births;changesTotal+=changes;const s=sig(nextG);if(seen.has(s)){period=i-seen.get(s);g=nextG;break;}seen.set(s,i);g=nextG;}if(period===null){const once=step(initial);if(eqGrid(initial,once))period=1;}const heat=steps?birthsTotal/steps:0;const volatility=steps?(changesTotal/(steps*(grid.length*(grid[0]?.length||0)))):0;let speed=null;{const g4=[cloneGrid(grid),step(cloneGrid(grid)),null,null,null];g4[2]=step(g4[1]);g4[3]=step(g4[2]);g4[4]=step(g4[3]);const d4=displacement(g4[0],g4[4]);if(d4.dx===1&&d4.dy===1)speed='c/4 (diagonal)';else{const g2=[cloneGrid(grid),step(cloneGrid(grid)),null];g2[2]=step(g2[1]);const d2=displacement(g2[0],g2[2]);if((Math.abs(d2.dx)===2&&d2.dy===0)||(Math.abs(d2.dy)===2&&d2.dx===0))speed='c/2 (orthogonal)';}}return{period:period??null,heat,volatility,speed};}
export class GridSession{constructor(patternText){this.history=[];this.current=parsePattern(patternText||'.');}next(){this.history.push(cloneGrid(this.current));this.current=step(this.current);return serializePattern(this.current);}prev(){if(this.history.length===0)return serializePattern(this.current);this.current=this.history.pop();return serializePattern(this.current);}measure(maxPeriod=10){return measure(this.current,maxPeriod);}load(patternText){this.history=[];this.current=parsePattern(patternText);}dump(){return serializePattern(this.current);}}
